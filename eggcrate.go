package eggcrate

import (
	"bytes"
	"encoding/base64"
	"encoding/gob"
	"errors"
	"fmt"
	"github.com/devplayg/golibs/compress"
	"github.com/devplayg/golibs/converter"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func Encode(config *Config) (int, error) {
	return encode(config.Dir, config.Extensions, config.UriPrefix, true, config.OutFile)
}

func encode(dir, extensions, uriPrefix string, compress bool, outFile string) (int, error) {
	dir = filepath.ToSlash(dir)
	if err := mustBeDirectory(dir); err != nil {
		return 0, err
	}
	if len(outFile) < 1 {
		return 0, errors.New("invalid output file")
	}

	extensionMap := createExtensionMap(extensions)

	files, err := getFilesWithExtensions(dir, extensionMap)
	if err != nil {
		//return 0, fmt.Errorf("fail to get files with extensions(%v): %w ", extensions, err)
		return 0, fmt.Errorf("fail to get files with extensions(%v): %w ", extensions, err)
	}
	if len(files) < 1 {
		return 0, nil
	}

	fileMap, err := generateFileMap(files, dir, uriPrefix, compress)
	if err != nil {
		return 0, err
	}

	encoded, err := converter.EncodeToBytes(fileMap)
	if err != nil {
		return 0, err
	}

	base64Encoded := base64.StdEncoding.EncodeToString(encoded)
	if err = writeData(base64Encoded, fileMap, outFile); err != nil {
		return 0, err
	}

	return len(encoded), nil
}

func Decode(encoded string) (map[string][]byte, error) {
	encoded = strings.ReplaceAll(encoded, "\n", "")
	var fileMap map[string][]byte

	decoded, err := base64.StdEncoding.DecodeString(encoded)
	if err != nil {
		return nil, err
	}
	dec := gob.NewDecoder(bytes.NewReader(decoded))
	return fileMap, dec.Decode(&fileMap)
}

func generateFileMap(files []string, dir, uriPrefix string, doCompress bool) (map[string][]byte, error) {
	m := make(map[string][]byte)
	var totalOrigin int64
	var totalCompressed int64

	for _, path := range files {
		data, err := ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}
		key := uriPrefix + "/" + strings.TrimPrefix(strings.TrimPrefix(path, dir), "/")
		totalOrigin += int64(len(data))

		if doCompress {
			compressed, err := compress.Compress(data, compress.GZIP)
			if err != nil {
				return nil, err
			}
			m[key] = compressed
			totalCompressed += int64(len(compressed))
			fmt.Printf("%s compressed (len=%d->%d)\n", path, len(data), len(compressed))
			continue
		}
		m[key] = data
		fmt.Printf("%s len=%d\n", key, len(data))
	}
	fmt.Printf("encoded: files=%d, uriPrefix=%s, size=(%d->%d) Bytes(%2.1f%%)\n", len(files), uriPrefix, totalOrigin, totalCompressed, float32(totalCompressed)/float32(totalOrigin)*100)

	fmt.Println()
	fmt.Println("map is generated")
	for k, _ := range m {
		fmt.Printf("map[%s][]byte(\"...\")\n", k)

	}
	return m, nil
}

func writeData(encoded string, fileMap map[string][]byte, output string) error {
	var qb bytes.Buffer

	fmt.Fprintf(&qb, "// Code generated by eggcrate. DO NOT EDIT.\n")
	fmt.Fprintf(&qb, "\n/*\n")
	keys := make([]string, 0)
	for k, _ := range fileMap {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		fmt.Fprintf(&qb, "\t%s\n", k)
	}
	fmt.Fprintf(&qb, "*/\n\n")
	fmt.Fprintf(&qb, "package %s\n\nvar assetData=`", "main")

	// qb.WriteString(encoded)
	size := len(encoded)
	n := 100
	for i := 0; i < size; i += n {
		end := i + n
		if end > size {
			end = size
			// fmt.Printf("%d-%d\n", i, end)
			qb.WriteString(encoded[i:end])
			break
		}
		// fmt.Printf("%d-%d\n", i, end)
		qb.WriteString(encoded[i:end] + "\n")

	}

	fmt.Fprint(&qb, "`")
	return ioutil.WriteFile(output, qb.Bytes(), 0644)
}

func getFilesWithExtensions(dir string, extMap map[string]bool) ([]string, error) {
	list := make([]string, 0)
	err := filepath.Walk(dir, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return nil
		}
		if f.IsDir() {
			return nil
		}
		if extMap == nil {
			list = append(list, filepath.ToSlash(path))
			return nil
		}
		if _, have := extMap[strings.ToLower(filepath.Ext(path))]; !have {
			return nil
		}
		list = append(list, filepath.ToSlash(path))
		return nil

	})
	return list, err
}

func createExtensionMap(str string) map[string]bool {
	if len(str) < 1 {
		return nil
	}

	m := make(map[string]bool)
	extensions := strings.Split(str, ",")
	if len(extensions) < 1 {
		return nil
	}

	for _, e := range extensions {
		ext := strings.TrimSpace(e)
		ext = strings.ToLower(strings.TrimPrefix(ext, "."))
		m["."+ext] = true
	}

	return m
}

func mustBeDirectory(dir string) error {
	f, err := os.Stat(dir)
	if err != nil {
		return err
	}
	if !f.IsDir() {
		return fmt.Errorf("%v is not a directory", dir)
	}
	return nil
}
