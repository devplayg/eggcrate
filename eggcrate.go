package eggcrate

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/gob"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

func createExtensionMap(str string) (map[string]bool, error) {
	m := make(map[string]bool)
	extensions := strings.Split(str, ",")
	if len(extensions) < 1 {
		return nil, errors.New("extensions required")
	}

	for _, e := range extensions {
		ext := strings.TrimSpace(e)
		ext = strings.TrimPrefix(ext, ".")
		m["."+ext] = true
	}

	return m, nil
}

func Decode(encoded string) (map[string][]byte, error) {
	var fileMap map[string][]byte

	compressed, err := base64.StdEncoding.DecodeString(encoded)
	if err != nil {
		return nil, err
	}

	decoded, err := decompress(compressed)
	if err != nil {
		return nil, err
	}

	dec := gob.NewDecoder(bytes.NewReader(decoded))
	return fileMap, dec.Decode(&fileMap)
}

func Encode(dir string, extensions string, outFile string) (*string, error) {
	dir = filepath.ToSlash(dir)
	extensionMap, err := createExtensionMap(extensions)
	if err != nil {
		return nil, err
	}

	files, err := getFilesWithExtensions(filepath.ToSlash(dir), extensionMap)
	if err != nil {
		return nil, err
	}
	if len(files) < 1 {
		return nil, errors.New("no files")
	}

	fileMap, err := generateFileMap(files, dir)
	if err != nil {
		return nil, err
	}
	encoded, _ := encodeToBytes(fileMap)

	compressed, err := compress(encoded)
	if err != nil {
		return nil, err
	}

	base64Encoded := base64.StdEncoding.EncodeToString(compressed)
	if err = writeData(base64Encoded, fileMap, outFile); err != nil {
		return nil, err
	}

	return &base64Encoded, nil
}

func encodeToBytes(p interface{}) ([]byte, error) {
	buf := bytes.Buffer{}
	enc := gob.NewEncoder(&buf)
	if err := enc.Encode(p); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func generateFileMap(files []string, dir string) (map[string][]byte, error) {
	m := make(map[string][]byte)
	var total int64
	for _, path := range files {
		data, err := ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}
		key := "/" + strings.TrimPrefix(strings.TrimPrefix(path, dir), "/")
		m[key] = data
		total += int64(len(data))
		fmt.Printf("[%s] len=%d\n", key, len(data))
	}
	fmt.Printf("processed: files: %d, size: %d Bytes\n", len(files), total)
	return m, nil
}

func writeData(encoded string, fileMap map[string][]byte, output string) error {
	var qb bytes.Buffer

	fmt.Fprintf(&qb, "// Code generated by eggcrate. DO NOT EDIT.\n")
	fmt.Fprintf(&qb, "\n/*\n")
	keys := make([]string, 0)
	for k, _ := range fileMap {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, k := range keys {
		fmt.Fprintf(&qb, "\t%s\n", k)
	}
	fmt.Fprintf(&qb, "*/\n\n")

	fmt.Fprintf(&qb, `
package %s

var assetData = "`, "server")
	qb.WriteString(encoded)
	fmt.Fprint(&qb, `"`)
	return ioutil.WriteFile(output, qb.Bytes(), 0644)
}

func compress(data []byte) ([]byte, error) {
	var b bytes.Buffer
	gz := gzip.NewWriter(&b)
	if _, err := gz.Write(data); err != nil {
		return nil, err
	}
	if err := gz.Close(); err != nil {
		return nil, err
	}
	return b.Bytes(), nil
}

func decompress(b []byte) ([]byte, error) {
	buf := bytes.NewBuffer(b)

	var r io.Reader
	var err error
	r, err = gzip.NewReader(buf)
	if err != nil {
		return nil, err
	}

	var resB bytes.Buffer
	_, err = resB.ReadFrom(r)
	if err != nil {
		return nil, err
	}

	return resB.Bytes(), nil

}

func getFilesWithExtensions(dir string, extMap map[string]bool) ([]string, error) {
	list := make([]string, 0)
	err := filepath.Walk(dir, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return nil
		}
		if f.IsDir() {
			return nil
		}
		if _, have := extMap[filepath.Ext(path)]; !have {
			return nil
		}

		list = append(list, filepath.ToSlash(path))
		return nil
	})
	return list, err
}
