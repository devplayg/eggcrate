package eggcrate

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func CreateExtensionMap(str string) (map[string]bool, error) {
	m := make(map[string]bool)
	extensions := strings.Split(str, ",")
	if len(extensions) < 1 {
		return nil, errors.New("extensions required")
	}

	for _, e := range extensions {
		ext := strings.TrimSpace(e)
		ext = strings.TrimPrefix(ext, ".")
		m["."+ext] = true
	}

	return m, nil
}

func CheckDir(path string) error {
	if len(path) < 1 {
		return errors.New("empty directory")
	}

	dir, err := os.Stat(path)
	if os.IsNotExist(err) {
		return errors.New("directory not found: " + path)
	}

	if !dir.IsDir() {
		return errors.New("invalid directory: " + path)
	}
	return nil
}

func Encode(dir string, extensionMap map[string]bool, outFile string) error {
	dir = filepath.ToSlash(dir)
	files, err := getFilesWithExts(dir, extensionMap)
	if err != nil {
		return err
	}
	if len(files) < 1 {
		return errors.New("no files")
	}

	m, err := encodeFiles(files, dir)
	if err != nil {
		return err
	}

	marshaled, _ := json.Marshal(m)

	compressed, err := compressData(marshaled)
	if err != nil {
		return err
	}
	if err = writeData(compressed, outFile); err != nil {
		return err
	}

	return nil
}

func encodeFiles(files []string, dir string) (map[string][]byte, error) {
	m := make(map[string][]byte)
	var total int64
	for _, path := range files {
		data, err := ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}
		key := "/" + strings.TrimPrefix(strings.TrimPrefix(path, dir), "/")
		m[key] = data
		total += int64(len(data))
		fmt.Printf("API: [%s] len=%d\n", key, len(data))
	}
	fmt.Printf("files: %d, size: %d Bytes", len(files), total)
	return m, nil
}

func writeData(data []byte, output string) error {
	var qb bytes.Buffer
	fmt.Fprintf(&qb, `// Code generated by eggcrate. DO NOT EDIT.
package %s

var assetData = "`, "server")

	qb.WriteString(base64.StdEncoding.EncodeToString(data))
	fmt.Fprint(&qb, `"`)
	return ioutil.WriteFile(output, qb.Bytes(), 0644)
}

//
func compressData(data []byte) ([]byte, error) {
	var b bytes.Buffer
	gz := gzip.NewWriter(&b)
	if _, err := gz.Write(data); err != nil {
		return nil, err
	}
	if err := gz.Close(); err != nil {
		return nil, err
	}
	return b.Bytes(), nil

}

func getFilesWithExts(dir string, extMap map[string]bool) ([]string, error) {
	list := make([]string, 0)
	err := filepath.Walk(dir, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return nil
		}
		if f.IsDir() {
			return nil
		}
		if _, exists := extMap[filepath.Ext(path)]; !exists {
			return nil
		}

		list = append(list, filepath.ToSlash(path))
		return nil
	})
	return list, err
}
