package eggcrate

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

func createExtensionMap(str string) (map[string]bool, error) {
	m := make(map[string]bool)
	extensions := strings.Split(str, ",")
	if len(extensions) < 1 {
		return nil, errors.New("extensions required")
	}

	for _, e := range extensions {
		ext := strings.TrimSpace(e)
		ext = strings.TrimPrefix(ext, ".")
		m["."+ext] = true
	}

	return m, nil
}

func Decode(encoded string) (map[string][]byte, error) {
	var fileMap map[string][]byte

	compressed, err := base64.StdEncoding.DecodeString(encoded)
	if err != nil {
		return nil, err
	}

	decoded, err := decompress(compressed)
	if err != nil {
		return nil, err
	}

	return fileMap, json.Unmarshal(decoded, &fileMap)
}

func Encode(dir string, extensions string, outFile string) (*string, error) {
	dir = filepath.ToSlash(dir)
	extensionMap, err := createExtensionMap(extensions)
	if err != nil {
		return nil, err
	}

	files, err := getFilesWithExts(filepath.ToSlash(dir), extensionMap)
	if err != nil {
		return nil, err
	}
	if len(files) < 1 {
		return nil, errors.New("no files")
	}

	fileMap, err := encodeFiles(files, dir)
	if err != nil {
		return nil, err
	}
	marshaled, _ := json.Marshal(fileMap)

	compressed, err := compress(marshaled)
	if err != nil {
		return nil, err
	}

	encoded := base64.StdEncoding.EncodeToString(compressed)
	if err = writeData(encoded, outFile); err != nil {
		return nil, err
	}

	return &encoded, nil
}

func encodeFiles(files []string, dir string) (map[string][]byte, error) {
	m := make(map[string][]byte)
	var total int64
	for _, path := range files {
		data, err := ioutil.ReadFile(path)
		if err != nil {
			return nil, err
		}
		key := "/" + strings.TrimPrefix(strings.TrimPrefix(path, dir), "/")
		m[key] = data
		total += int64(len(data))
		fmt.Printf("[%s] len=%d\n", key, len(data))
	}
	fmt.Printf("processed: files: %d, size: %d Bytes\n", len(files), total)
	return m, nil
}

func writeData(encoded string, output string) error {
	var qb bytes.Buffer
	fmt.Fprintf(&qb, `// Code generated by eggcrate. DO NOT EDIT.
package %s

var assetData = "`, "server")
	qb.WriteString(encoded)
	fmt.Fprint(&qb, `"`)
	return ioutil.WriteFile(output, qb.Bytes(), 0644)
}

func compress(data []byte) ([]byte, error) {
	var b bytes.Buffer
	gz := gzip.NewWriter(&b)
	if _, err := gz.Write(data); err != nil {
		return nil, err
	}
	if err := gz.Close(); err != nil {
		return nil, err
	}
	return b.Bytes(), nil
}

func decompress(b []byte) ([]byte, error) {
	buf := bytes.NewBuffer(b)

	var r io.Reader
	var err error
	r, err = gzip.NewReader(buf)
	if err != nil {
		return nil, err
	}

	var resB bytes.Buffer
	_, err = resB.ReadFrom(r)
	if err != nil {
		return nil, err
	}

	return resB.Bytes(), nil

}

func getFilesWithExts(dir string, extMap map[string]bool) ([]string, error) {
	list := make([]string, 0)
	err := filepath.Walk(dir, func(path string, f os.FileInfo, err error) error {
		if f == nil {
			return nil
		}
		if f.IsDir() {
			return nil
		}
		if _, exists := extMap[filepath.Ext(path)]; !exists {
			return nil
		}

		list = append(list, filepath.ToSlash(path))
		return nil
	})
	return list, err
}
